/*
 * ExampleTypes.idl
 * 
 * IDL definitions for example data types with basic members
 * Simple types for demonstration and testing purposes
 */

module example_types {
    
    // Maximum string lengths for bounded strings
    const unsigned long MAX_ID_LENGTH = 32;
    const unsigned long MAX_NAME_LENGTH = 64;
    const unsigned long MAX_MESSAGE_LENGTH = 128;
    const unsigned long MAX_VALUE_LENGTH = 128;
    const unsigned long MAX_IMAGE_DATA_SIZE = 3145728;  // 3 MB (3 * 1024 * 1024)
    const unsigned long MAX_POINT_CLOUD_SIZE = 512000;  // 500 KB (500 * 1024)
    
    // Basic enumerations
    enum CommandType {
        START = 0,  // drop pre-ambles for better discovery performance, keeping unique across all Enums
        STOP,
        PAUSE,
        RESET,
        SHUTDOWN
    };
    
    enum SystemState {
        INIT,
        RUNNING = 0,  // use type default for common case 
        ERROR,
        RESTARTING,
        SHUTTING_DOWN
    };
    
    enum ButtonState {
        RELEASED = 0,
        PRESSED,
        HELD,
        DOUBLE_CLICK
    };
    
    /**
     * Command - Basic command structure
     */
    struct Command {
        @key string<MAX_ID_LENGTH> command_id;     // Unique command identifier
        string<MAX_ID_LENGTH> destination_id; // Target destination identifier
        CommandType command_type;                   // Type of command
        string<MAX_MESSAGE_LENGTH> message;         // Command message or description
        // unsigned long timestamp_sec;               // Command timestamp - drop in favor of metadata
        unsigned short urgent;                            // Priority value: higher = more urgent
    };
    
    /**
     * Config - Basic configuration structure
     */
    struct Config {
        @key string<MAX_ID_LENGTH> destination_id;      // Configuration identifier
        string<MAX_NAME_LENGTH> parameter_name;    // Parameter name
        string<MAX_VALUE_LENGTH> parameter_value; // Parameter value
        double numeric_value;                       // Numeric parameter value
        boolean enabled;                           // Enable/disable flag
    };
    
    /**
     * Position - Current location reporting structure
     */
    struct Position {
        @key string<MAX_ID_LENGTH> source_id;      // Source identifier
        double latitude;                            // Latitude in degrees
        double longitude;                          // Longitude in degrees
        double altitude;                           // Altitude in meters
        unsigned long timestamp_sec;              // Position timestamp
    };
    
    /**
     * State - Basic state information structure
     */
    struct State {
        @key string<MAX_ID_LENGTH> source_id;      // Source identifier
        SystemState state_value;                    // State enumeration
        string<MAX_MESSAGE_LENGTH> error_message;   // Error message or status description
    };
    
    /**
     * Button - Basic button input structure
     */
    struct Button {
        @key string<MAX_ID_LENGTH> source_id;      // Source identifier
        @key string<MAX_ID_LENGTH> button_id;      // Button identifier
        ButtonState button_state;                   // Current button state
        unsigned long press_count;                 // Total press count
        unsigned long last_press_timestamp_sec;    // Last press time
        double hold_duration_sec;                  // Hold duration for held buttons
    };
    
    /**
     * Image - Basic image data structure
     */
    struct Image {
        @key string<MAX_ID_LENGTH> image_id;       // Image identifier
        unsigned long width;                       // Image width in pixels
        unsigned long height;                      // Image height in pixels
        string<MAX_NAME_LENGTH> format;            // Image format (e.g., "RGB", "JPEG")
        sequence<octet, MAX_IMAGE_DATA_SIZE> data; // Image data bytes
    };

// consider factoring out image width+height as nested structure for reuse

    /**
     * FinalFlatImage - High-performance image structure using @final FlatData
     * @final provides maximum zero-copy performance but requires only fixed-size types
     * Uses numeric format code instead of string, and fixed-size array instead of sequence
     */
    @final
    @transfer_mode(SHMEM_REF)
    @language_binding(FLAT_DATA)
    struct FinalFlatImage {
        @key unsigned long image_id;                   // Numeric image identifier
        unsigned short width;                           // Image width in pixels
        unsigned short height;                          // Image height in pixels
        unsigned short format;                          // Format code: 0=RGB, 1=RGBA, 2=JPEG, etc.
        octet data[MAX_IMAGE_DATA_SIZE];              // Fixed-size image data array
    };

    /**
     * FinalFlatPointCloud - High-performance image structure using @final FlatData, 500 KB version
     * @final provides maximum zero-copy performance but requires only fixed-size types
     */
    @final
    @transfer_mode(SHMEM_REF)
    @language_binding(FLAT_DATA)
    struct FinalFlatPointCloud {
        @key unsigned long point_cloud_id;        // Point cloud identifier
        octet data[MAX_POINT_CLOUD_SIZE];         // Fixed-size image data array
    };

    
}; // namespace example_types



// Generated by https://github.com/foxglove/foxglove-sdk

module foxglove {

// Bound large sequences to avoid Connext treating them as ~2GB maximum samples.
// Keep this in sync with the SHMEM transport message_size_max in dds/qos/DDS_QOS_PROFILES.xml.
const unsigned long MAX_RAW_IMAGE_DATA_SIZE = 3145728; // 3 MiB

// A timestamp composed of seconds and nanoseconds
struct Time {
  // The number of seconds since a user-defined epoch
  uint32 sec;

  // The number of nanoseconds since the sec value
  uint32 nsec;
};

// GeoJSON data for annotating maps
struct GeoJSON {
  // GeoJSON data encoded as a UTF-8 string
  string geojson;
};

// A raw image
struct RawImage {
  // Timestamp of image
  Time timestamp;

  // Frame of reference for the image. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
  string frame_id;

  // Image width in pixels
  uint32 width;

  // Image height in pixels
  uint32 height;

  // Encoding of the raw image data. See the `data` field description for supported values.
  string encoding;

  // Byte length of a single row. This is usually some multiple of `width` depending on the encoding, but can be greater to incorporate padding.
  uint32 step;

  // Raw image data.
  // 
  // For each `encoding` value, the `data` field contains image pixel data serialized as follows:
  // 
  // - `yuv422` or `uyvy`:
  //   - Pixel colors are decomposed into [Y'UV](https://en.wikipedia.org/wiki/Y%E2%80%B2UV) channels.
  //   - Pixel channel values are represented as unsigned 8-bit integers.
  //   - U and V values are shared between horizontal pairs of pixels. Each pair of output pixels is serialized as [U, Y1, V, Y2].
  //   - `step` must be greater than or equal to `width` * 2.
  // - `yuv422_yuy2` or  `yuyv`:
  //   - Pixel colors are decomposed into [Y'UV](https://en.wikipedia.org/wiki/Y%E2%80%B2UV) channels.
  //   - Pixel channel values are represented as unsigned 8-bit integers.
  //   - U and V values are shared between horizontal pairs of pixels. Each pair of output pixels is encoded as [Y1, U, Y2, V].
  //   - `step` must be greater than or equal to `width` * 2.
  // - `rgb8`:
  //   - Pixel colors are decomposed into Red, Green, and Blue channels.
  //   - Pixel channel values are represented as unsigned 8-bit integers.
  //   - Each output pixel is serialized as [R, G, B].
  //   - `step` must be greater than or equal to `width` * 3.
  // - `rgba8`:
  //   - Pixel colors are decomposed into Red, Green, Blue, and Alpha channels.
  //   - Pixel channel values are represented as unsigned 8-bit integers.
  //   - Each output pixel is serialized as [R, G, B, Alpha].
  //   - `step` must be greater than or equal to `width` * 4.
  // - `bgr8` or `8UC3`:
  //   - Pixel colors are decomposed into Blue, Green, and Red channels.
  //   - Pixel channel values are represented as unsigned 8-bit integers.
  //   - Each output pixel is serialized as [B, G, R].
  //   - `step` must be greater than or equal to `width` * 3.
  // - `bgra8`:
  //   - Pixel colors are decomposed into Blue, Green, Red, and Alpha channels.
  //   - Pixel channel values are represented as unsigned 8-bit integers.
  //   - Each output pixel is encoded as [B, G, R, Alpha].
  //   - `step` must be greater than or equal to `width` * 4.
  // - `32FC1`:
  //   - Pixel brightness is represented as a single-channel, 32-bit little-endian IEEE 754 floating-point value, ranging from 0.0 (black) to 1.0 (white).
  //   - `step` must be greater than or equal to `width` * 4.
  // - `bayer_rggb8`, `bayer_bggr8`, `bayer_gbrg8`, or `bayer_grbg8`:
  //   - Pixel colors are decomposed into Red, Blue and Green channels.
  //   - Pixel channel values are represented as unsigned 8-bit integers, and serialized in a 2x2 bayer filter pattern.
  //   - The order of the four letters after `bayer_` determine the layout, so for `bayer_wxyz8` the pattern is:
  //   ```plaintext
  //   w | x
  //   - + -
  //   y | z
  //   ```
  //   - `step` must be greater than or equal to `width`.
  // - `mono8` or `8UC1`:
  //   - Pixel brightness is represented as unsigned 8-bit integers.
  //   - `step` must be greater than or equal to `width`.
  // - `mono16` or `16UC1`:
  //   - Pixel brightness is represented as 16-bit unsigned little-endian integers. Rendering of these values is controlled in [Image panel color mode settings](https://docs.foxglove.dev/docs/visualization/panels/image#general).
  //   - `step` must be greater than or equal to `width` * 2.
    sequence<uint8, MAX_RAW_IMAGE_DATA_SIZE> data;
};


};
